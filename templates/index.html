<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
    <title>MapFlow</title>
    <style>
        /* Inline style trimmed; see static/styles.css for layout */
    </style>
    <script>
    let graph = null;
    let currentCity = null;
    let selectedNodes = [];
    let hoveredNode = null;
    let canvas, ctx;
    const margin = 20;

    // Performance caches
    let nodePos = {};     // nodeId -> {x, y}
    let uniqueEdges = []; // [{n1, n2}]
    let pathNodes = [];   // current path returned by server
    let hoverRAF = null;  // throttle mousemove
    let anim = {
        playing: false,
        queue: [],
        index: 0,
        timer: null,
        raf: null,
        _visitedSet: new Set(),
        baseNodesPerFrame: 0,
        // Speed multiplier is derived from slider display value v: internal = v * 0.1
        speedMultiplier: 0.1,   // default at slider 1.0x => internal 0.1 (half of previous 0.2)
        glow: new Map(),        // nodeId -> intensity [0..1]
        lastTs: 0,
        glowDecayPerSec: 3.0,   // higher = faster fade
        // final path glow state
        pathActive: false,
        pathRaf: null,
        pathLastTs: 0,
        pathGlowIntensity: 0,
    pathDecayPerSec: 0.5,   // slow fade for final path
    // lightning flash state (map-wide bloom)
    flashActive: false,
    flashRaf: null,
    flashLastTs: 0,
    flashGlowIntensity: 0,
    flashDecayPerSec: 3.0,
    flashCenter: { x: 0, y: 0 }
    };
    // Spatial index for fast hover
    let grid = null; let cellSize = 24; let gridCols = 0, gridRows = 0, gridMinX = 0, gridMinY = 0;
    // Pre-rendered base layer (edges + tiny node dots) for big maps
    let baseLayerCanvas = null;
    let baseLayerBitmap = null; // ImageBitmap for fast blit when supported
    // Glow layers (low-res) and sprite for fast rendering
    const glowScale = 1.5; // render glow at half resolution for speed
    let glowStatCanvas = null, glowStatCtx = null; // persistent faint glows
    let glowDynCanvas = null, glowDynCtx = null;   // dynamic bright glows
    let glowSprite = null; // radial gradient sprite

    function sendCity(city) {
        currentCity = city;
        selectedNodes = [];
        hoveredNode = null;
        pathNodes = [];
        // Clear any existing animation and glow when changing city
        stopAnimation(true);
        // reset base layer (will rebuild after load)
        baseLayerCanvas = null; baseLayerBitmap = null;
        // reset glow layers
        buildGlowLayers();
        const overlay = document.getElementById('loadingOverlay');
        const loadingText = document.getElementById('loadingText');
        if (loadingText) loadingText.textContent = `Loading ${city}â€¦`;
        if (overlay) overlay.classList.add('show');

        fetch('/get_city', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ city: city })
        })
        .then(response => response.json())
        .then(data => {
            graph = data; // keep as-is; no deep copy
            calculateBounds();
            precomputePositions();
            buildUniqueEdges();
            buildSpatialIndex();
            buildBaseLayer().then(() => drawGraph());
            updateHUD();
            if (overlay) overlay.classList.remove('show');
        })
        .catch(error => {
            console.error('Error:', error);
            if (loadingText) loadingText.textContent = `Failed to load ${city}`;
            setTimeout(() => overlay && overlay.classList.remove('show'), 1200);
        });
    }

    // Build low-res glow canvases and sprite
    function buildGlowLayers() {
        const w = Math.max(2, Math.floor((canvas ? canvas.width : 0) * glowScale));
        const h = Math.max(2, Math.floor((canvas ? canvas.height : 0) * glowScale));
        glowStatCanvas = document.createElement('canvas');
        glowStatCanvas.width = w; glowStatCanvas.height = h;
        glowStatCtx = glowStatCanvas.getContext('2d');
        glowDynCanvas = document.createElement('canvas');
        glowDynCanvas.width = w; glowDynCanvas.height = h;
        glowDynCtx = glowDynCanvas.getContext('2d');
        // clear
        glowStatCtx.clearRect(0,0,w,h);
        glowDynCtx.clearRect(0,0,w,h);
        glowSprite = createGlowSprite(64);
    }

    function createGlowSprite(size) {
        const off = document.createElement('canvas');
        off.width = size; off.height = size;
        const g = off.getContext('2d');
        const cx = size/2, cy = size/2, r = size/2;
        const grad = g.createRadialGradient(cx, cy, 0, cx, cy, r);
        grad.addColorStop(0.0, 'rgba(220, 240, 255, 1)');
        grad.addColorStop(0.35, 'rgba(120, 200, 255, 0.45)');
        grad.addColorStop(1.0, 'rgba(120, 200, 255, 0)');
        g.fillStyle = grad;
        g.beginPath(); g.arc(cx, cy, r, 0, 2*Math.PI); g.fill();
        return off;
    }


    function calculateBounds() {
        minLat = Infinity;
        maxLat = -Infinity;
        minLon = Infinity;
        maxLon = -Infinity;

        for (let nodeId in graph.nodes) {
            const node = graph.nodes[nodeId];
            if (node.latitude < minLat) minLat = node.latitude;
            if (node.latitude > maxLat) maxLat = node.latitude;
            if (node.longitude < minLon) minLon = node.longitude;
            if (node.longitude > maxLon) maxLon = node.longitude;
        }
    }

    function mapToCanvas(lat, lon) {
        const x = ((lon - minLon) / (maxLon - minLon)) * (canvas.width - 2 * margin) + margin;
        const y = ((lat - minLat) / (maxLat - minLat)) * (canvas.height - 2 * margin) + margin;
        return { x: x, y: canvas.height - y };
    }

    // Precompute node screen positions once
    function precomputePositions() {
        nodePos = {};
        for (let nodeId in graph.nodes) {
            const n = graph.nodes[nodeId];
            nodePos[nodeId] = mapToCanvas(n.latitude, n.longitude);
        }
    }

    // Build a unique edge list so we draw each edge once
    function buildUniqueEdges() {
        uniqueEdges = [];
        const seen = new Set();
        for (let nodeId in graph.nodes) {
            const node = graph.nodes[nodeId];
            node.edges.forEach(e => {
                const a = String(e.node1_id);
                const b = String(e.node2_id);
                const key = a < b ? a + '-' + b : b + '-' + a;
                if (!seen.has(key)) {
                    seen.add(key);
                    uniqueEdges.push({ n1: a, n2: b });
                }
            });
        }
    }

    // Build pre-rendered base layer for heavy static content
    async function buildBaseLayer() {
        if (!graph) { baseLayerCanvas = null; baseLayerBitmap = null; return; }
        baseLayerBitmap = null;
        const off = document.createElement('canvas');
        off.width = canvas.width;
        off.height = canvas.height;
        const octx = off.getContext('2d');
    // Edges (slightly brighter neon-blue for readability)
    octx.lineWidth = 0.12;
    octx.strokeStyle = 'rgba(90, 160, 255, 0.38)';
        octx.beginPath();
        for (let i = 0; i < uniqueEdges.length; i++) {
            const { n1, n2 } = uniqueEdges[i];
            const p1 = nodePos[n1];
            const p2 = nodePos[n2];
            octx.moveTo(p1.x, p1.y);
            octx.lineTo(p2.x, p2.y);
        }
        octx.stroke();
        // Do not draw base node dots; only edges for a clean initial map
        baseLayerCanvas = off;
        if (window.createImageBitmap) {
            try { baseLayerBitmap = await createImageBitmap(off); } catch (_) { baseLayerBitmap = null; }
        }
    }

    // Build grid index over node positions for fast nearest lookup
    function buildSpatialIndex() {
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        for (let id in nodePos) {
            const p = nodePos[id];
            if (p.x < minX) minX = p.x;
            if (p.y < minY) minY = p.y;
            if (p.x > maxX) maxX = p.x;
            if (p.y > maxY) maxY = p.y;
        }
        gridMinX = Math.floor(minX);
        gridMinY = Math.floor(minY);
        gridCols = Math.max(1, Math.ceil((maxX - gridMinX) / cellSize));
        gridRows = Math.max(1, Math.ceil((maxY - gridMinY) / cellSize));
        grid = new Map();
        const key = (cx, cy) => `${cx},${cy}`;
        for (let id in nodePos) {
            const p = nodePos[id];
            const cx = Math.min(gridCols - 1, Math.max(0, Math.floor((p.x - gridMinX) / cellSize)));
            const cy = Math.min(gridRows - 1, Math.max(0, Math.floor((p.y - gridMinY) / cellSize)));
            const k = key(cx, cy);
            if (!grid.has(k)) grid.set(k, []);
            grid.get(k).push(id);
        }
    }

    function drawGraph() {
        if (!graph) return;

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw pre-rendered base layer (edges + base node dots)
        if (baseLayerBitmap) {
            ctx.drawImage(baseLayerBitmap, 0, 0);
        } else if (baseLayerCanvas) {
            ctx.drawImage(baseLayerCanvas, 0, 0);
        } else {
            // Fallback to direct draw (first frame before base builds)
            ctx.save();
            ctx.lineWidth = 0.12;
            ctx.strokeStyle = 'rgba(90, 160, 255, 0.38)';
            ctx.beginPath();
            for (let i = 0; i < uniqueEdges.length; i++) {
                const { n1, n2 } = uniqueEdges[i];
                const p1 = nodePos[n1];
                const p2 = nodePos[n2];
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
            }
            ctx.stroke();
            ctx.restore();
        }

        // Composite glow layers (persistent + dynamic) in lighter mode
        if (glowStatCanvas && glowDynCanvas) {
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            ctx.imageSmoothingEnabled = true;
            ctx.drawImage(glowStatCanvas, 0, 0, canvas.width, canvas.height);
            ctx.drawImage(glowDynCanvas, 0, 0, canvas.width, canvas.height);
            ctx.restore();
        }

        // Lightning-like flash overlay after final path found
        if (anim.flashActive && anim.flashGlowIntensity > 0) {
            const c = anim.flashCenter || { x: canvas.width/2, y: canvas.height/2 };
            const maxR = Math.hypot(Math.max(c.x, canvas.width - c.x), Math.max(c.y, canvas.height - c.y));
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            // Large radial gradient from center fading to edges
            const g = ctx.createRadialGradient(c.x, c.y, 0, c.x, c.y, maxR);
            const a0 = Math.min(0.5, 0.15 + 0.5 * anim.flashGlowIntensity);
            const a1 = Math.max(0, a0 * 0.35);
            g.addColorStop(0.0, `rgba(200, 220, 255, ${a0})`);
            g.addColorStop(0.35, `rgba(120, 180, 255, ${a1})`);
            g.addColorStop(1.0, 'rgba(120, 180, 255, 0)');
            ctx.fillStyle = g;
            ctx.beginPath();
            ctx.arc(c.x, c.y, maxR, 0, 2*Math.PI);
            ctx.fill();
            // Subtle uniform lift to ensure whole map lights up a bit
            ctx.globalAlpha = 0.08 * anim.flashGlowIntensity;
            ctx.fillStyle = '#bcd6ff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.restore();
        }

    // Draw returned path as a single polyline (not during animation)
    if (!anim.playing && pathNodes && pathNodes.length > 1) {
            ctx.save();
            ctx.lineWidth = 1.5;
            ctx.strokeStyle = 'rgba(180, 210, 255, 0.9)';
            ctx.beginPath();
            const first = nodePos[pathNodes[0]];
            ctx.moveTo(first.x, first.y);
            for (let i = 1; i < pathNodes.length; i++) {
                const p = nodePos[pathNodes[i]];
                ctx.lineTo(p.x, p.y);
            }
            ctx.stroke();
            ctx.restore();

            // Bright glow overlay for final path (slowly dims)
            if (anim.pathActive && anim.pathGlowIntensity > 0) {
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                ctx.lineWidth = 2 + 6 * anim.pathGlowIntensity;
                ctx.strokeStyle = `rgba(160, 200, 255, ${Math.min(0.9, 0.35 + 0.55 * anim.pathGlowIntensity)})`;
                ctx.shadowColor = 'rgba(120, 180, 255, 1)';
                ctx.shadowBlur = 14 + 34 * anim.pathGlowIntensity;
                ctx.beginPath();
                const f2 = nodePos[pathNodes[0]];
                ctx.moveTo(f2.x, f2.y);
                for (let i = 1; i < pathNodes.length; i++) {
                    const p = nodePos[pathNodes[i]];
                    ctx.lineTo(p.x, p.y);
                }
                ctx.stroke();
                ctx.restore();
            }
        }

    // Removed per-node gradient glow drawing; now handled via glow layers above
        // Overlay for selected/hovered nodes (draw larger circles)
        ctx.save();
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 0.5;
        const drawNodeOverlay = (nodeId, color) => {
            const pos = nodePos[nodeId];
            if (!pos) return;
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, 3, 0, 2 * Math.PI);
            ctx.fillStyle = color;
            ctx.fill();
            ctx.stroke();
        };
        // Selected nodes with neon-blue glows and gradient bloom
        if (selectedNodes[0]) {
            ctx.save();
            ctx.shadowColor = 'rgba(120, 200, 255, 0.9)';
            ctx.shadowBlur = 14;
            drawNodeOverlay(selectedNodes[0], 'rgba(80, 200, 255, 0.95)');
            // Selected bloom: draw sprite once
            const p = nodePos[selectedNodes[0]];
            if (p && glowSprite) {
                ctx.globalCompositeOperation = 'lighter';
                const r = 8;
                ctx.globalAlpha = 0.6;
                ctx.drawImage(glowSprite, p.x - r, p.y - r, r*2, r*2);
                ctx.globalAlpha = 1;
            }
            ctx.restore();
        }
        if (selectedNodes[1]) {
            ctx.save();
            ctx.shadowColor = 'rgba(150, 210, 255, 0.9)';
            ctx.shadowBlur = 14;
            drawNodeOverlay(selectedNodes[1], 'rgba(190, 225, 255, 0.95)');
            const p2 = nodePos[selectedNodes[1]];
            if (p2 && glowSprite) {
                ctx.globalCompositeOperation = 'lighter';
                const r2 = 8;
                ctx.globalAlpha = 0.6;
                ctx.drawImage(glowSprite, p2.x - r2, p2.y - r2, r2*2, r2*2);
                ctx.globalAlpha = 1;
            }
            ctx.restore();
        }
        if (hoveredNode && !selectedNodes.includes(hoveredNode)) {
            drawNodeOverlay(hoveredNode, 'rgb(100, 180, 255)');
            const ph = nodePos[hoveredNode];
            if (ph && glowSprite) {
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                ctx.globalAlpha = 0.35;
                const rh = 6;
                ctx.drawImage(glowSprite, ph.x - rh, ph.y - rh, rh*2, rh*2);
                ctx.globalAlpha = 1;
                ctx.restore();
            }
        }
        ctx.restore();
    }

    function findClosestNode(x, y) {
        if (!graph || !graph.nodes || !grid) return null;
        const cx = Math.min(gridCols - 1, Math.max(0, Math.floor((x - gridMinX) / cellSize)));
        const cy = Math.min(gridRows - 1, Math.max(0, Math.floor((y - gridMinY) / cellSize)));
        const key = (ix, iy) => `${ix},${iy}`;
        let closestNode = null; let minDist = Infinity;
        for (let iy = cy - 1; iy <= cy + 1; iy++) {
            if (iy < 0 || iy >= gridRows) continue;
            for (let ix = cx - 1; ix <= cx + 1; ix++) {
                if (ix < 0 || ix >= gridCols) continue;
                const arr = grid.get(key(ix, iy));
                if (!arr) continue;
                for (let i = 0; i < arr.length; i++) {
                    const id = arr[i];
                    const p = nodePos[id];
                    const dx = p.x - x, dy = p.y - y; const d2 = dx*dx + dy*dy;
                    if (d2 < minDist) { minDist = d2; closestNode = id; }
                }
            }
        }
        return closestNode;
    }

    function handleCanvasClick(event) {
        const rect = canvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;

        const closestNodeId = findClosestNode(x, y);
        if (closestNodeId) {
            if (selectedNodes.length < 2 && !selectedNodes.includes(closestNodeId)) {
                selectedNodes.push(closestNodeId);
            }
            updateHUD();
            drawGraph();
        }
    }

    // Smooth hover with RAF using the latest mouse position
    let lastMouse = null;
    function handleMouseMove(event) {
        if (!graph || !graph.nodes || selectedNodes.length >= 2) return;
        const rect = canvas.getBoundingClientRect();
        lastMouse = { x: event.clientX - rect.left, y: event.clientY - rect.top };
        if (hoverRAF) return;
        hoverRAF = requestAnimationFrame(() => {
            hoverRAF = null;
            if (!lastMouse) return;
            const closestNodeId = findClosestNode(lastMouse.x, lastMouse.y);
            if (closestNodeId !== hoveredNode) {
                hoveredNode = closestNodeId;
                updateHUD();
                drawGraph();
            }
        });
    }

    function resetSelection() {
        stopAnimation(true); // also clear persistent glow on reset
        selectedNodes = [];
        hoveredNode = null;
        pathNodes = [];
    drawGraph();
    updateHUD();
    }

    function stopAnimation(clearGlow = false) {
        anim.playing = false;
        anim.queue = [];
        anim.index = 0;
        anim._visitedSet = new Set();
        if (clearGlow) {
            anim.glow = new Map(); // clear set
            // also clear glow layers to remove any residual bloom
            if (glowDynCtx && glowDynCanvas) glowDynCtx.clearRect(0,0,glowDynCanvas.width, glowDynCanvas.height);
            if (glowStatCtx && glowStatCanvas) glowStatCtx.clearRect(0,0,glowStatCanvas.width, glowStatCanvas.height);
        }
        if (anim.timer) {
            clearInterval(anim.timer);
            anim.timer = null;
        }
        if (anim.raf) {
            cancelAnimationFrame(anim.raf);
            anim.raf = null;
        }
        if (anim.pathRaf) {
            cancelAnimationFrame(anim.pathRaf);
            anim.pathRaf = null;
        }
        anim.pathActive = false;
        anim.pathGlowIntensity = 0;
        anim.pathLastTs = 0;
    }

    function startAnimation(visited, finalPath) {
    stopAnimation(false);
        anim.playing = true;
        anim.queue = (visited || []).map(String);
        anim.index = 0;
        anim._visitedSet = new Set();
    anim.glow = new Map(); // still used for selection logic; not drawn per-node
        anim.lastTs = 0;
    anim.frameStamps = [];

    // Base nodes per frame aims for ~0.5s; actual rate = base * speedMultiplier
    const total = anim.queue.length || 1;
    anim.baseNodesPerFrame = Math.max(50, Math.ceil(total / 30));

        const step = (ts) => {
            if (!anim.playing) return;
            if (!anim.lastTs) anim.lastTs = ts;
            const dt = Math.max(0, (ts - anim.lastTs) / 1000);
            anim.lastTs = ts;

            // Consume a batch this frame using current speed multiplier
            const nodesThisFrame = Math.max(1, Math.ceil((anim.baseNodesPerFrame || 1) * (anim.speedMultiplier || 1)));
            const end = Math.min(anim.index + nodesThisFrame, anim.queue.length);
            for (let i = anim.index; i < end; i++) {
                const id = anim.queue[i];
                anim._visitedSet.add(id);
                anim.glow.set(id, 1.0);
                const p = nodePos[id];
                if (p) anim.frameStamps.push(p);
            }
            anim.index = end;

            // Update glow layers: fade dynamic, stamp new nodes to both layers
            updateGlowLayers(dt);

            drawGraph();

            if (anim.index >= anim.queue.length) {
                // Done: stop animation and show only final path (remove node glow entirely)
                stopAnimation(true);
                pathNodes = (finalPath || []).map(String);
                // compute flash center and trigger a short lightning-like bloom
                const c = computePathCenter();
                anim.flashCenter = c;
                startMapFlash();
                startPathGlow();
                drawGraph();
                return;
            }

            anim.raf = requestAnimationFrame(step);
        };

        anim.raf = requestAnimationFrame(step);
    }

    function updateGlowLayers(dt) {
        if (!glowDynCtx || !glowStatCtx || !glowSprite) return;
        const w = glowDynCanvas.width, h = glowDynCanvas.height;
        // Fade dynamic layer
        const fade = Math.exp(-4.0 * (dt || 0)); // tune for trail length
        glowDynCtx.save();
        glowDynCtx.globalCompositeOperation = 'destination-in';
        glowDynCtx.globalAlpha = fade;
        glowDynCtx.fillStyle = 'rgba(0,0,0,1)';
        glowDynCtx.fillRect(0, 0, w, h);
        glowDynCtx.restore();

        // Stamp new nodes
        if (anim.frameStamps && anim.frameStamps.length) {
            glowDynCtx.save();
            glowStatCtx.save();
            glowDynCtx.globalCompositeOperation = 'lighter';
            glowStatCtx.globalCompositeOperation = 'lighter';
            for (const p of anim.frameStamps) {
                const sx = Math.floor(p.x * glowScale);
                const sy = Math.floor(p.y * glowScale);
                    const rDyn = 4;  // dynamic bright radius (smaller for tighter glow)
                    const rStat = 2; // persistent faint radius (smaller)
                // dynamics
                glowDynCtx.globalAlpha = 0.8;
                glowDynCtx.drawImage(glowSprite, sx - rDyn, sy - rDyn, rDyn*2, rDyn*2);
                // persistent faint
                glowStatCtx.globalAlpha = 0.22;
                glowStatCtx.drawImage(glowSprite, sx - rStat, sy - rStat, rStat*2, rStat*2);
            }
            glowDynCtx.restore();
            glowStatCtx.restore();
            anim.frameStamps.length = 0;
        }
    }

    function startPathGlow() {
        anim.pathActive = true;
        anim.pathGlowIntensity = 1.0; // bright at start
        anim.pathLastTs = 0;

        const stepPath = (ts) => {
            if (!anim.pathActive) return;
            if (!anim.pathLastTs) anim.pathLastTs = ts;
            const dt = Math.max(0, (ts - anim.pathLastTs) / 1000);
            anim.pathLastTs = ts;

            // slow exponential decay
            const factor = Math.exp(-anim.pathDecayPerSec * dt);
            anim.pathGlowIntensity *= factor;
            if (anim.pathGlowIntensity < 0.03) {
                anim.pathActive = false;
                anim.pathGlowIntensity = 0;
                drawGraph();
                return;
            }

            drawGraph();
            anim.pathRaf = requestAnimationFrame(stepPath);
        };

        anim.pathRaf = requestAnimationFrame(stepPath);
    }

    function computePathCenter() {
        if (!pathNodes || pathNodes.length === 0) return { x: canvas.width/2, y: canvas.height/2 };
        let sx = 0, sy = 0, n = 0;
        for (let i = 0; i < pathNodes.length; i++) {
            const p = nodePos[pathNodes[i]];
            if (!p) continue;
            sx += p.x; sy += p.y; n++;
        }
        if (n === 0) return { x: canvas.width/2, y: canvas.height/2 };
        return { x: sx / n, y: sy / n };
    }

    function startMapFlash() {
        anim.flashActive = true;
        anim.flashGlowIntensity = 1.0;
        anim.flashLastTs = 0;
        if (anim.flashRaf) cancelAnimationFrame(anim.flashRaf);
        const stepFlash = (ts) => {
            if (!anim.flashActive) return;
            if (!anim.flashLastTs) anim.flashLastTs = ts;
            const dt = Math.max(0, (ts - anim.flashLastTs) / 1000);
            anim.flashLastTs = ts;
            const factor = Math.exp(-anim.flashDecayPerSec * dt);
            anim.flashGlowIntensity *= factor;
            if (anim.flashGlowIntensity < 0.02) {
                anim.flashActive = false;
                anim.flashGlowIntensity = 0;
                drawGraph();
                return;
            }
            drawGraph();
            anim.flashRaf = requestAnimationFrame(stepFlash);
        };
        anim.flashRaf = requestAnimationFrame(stepFlash);
    }

    function findPath(algorithm) {
        if (!graph || selectedNodes.length < 2) {
            alert('Please select two nodes first!');
            return;
        }

        const payload = {
            start_id: selectedNodes[0],
            end_id: selectedNodes[1],
            algorithm: algorithm,
            city: currentCity || undefined
        };

        fetch('/pathfind', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        })
        .then(response => {
            if (!response.ok) throw new Error('Failed to find path: ' + response.statusText);
            return response.json();
        })
        .then(data => {
            const path = Array.isArray(data.path) ? data.path : [];
            const visited = Array.isArray(data.visited) ? data.visited : [];
            startAnimation(visited, path);
        })
        .catch(error => console.error('Error:', error));
    }

    function updateHUD() {
        const hudCity = document.getElementById('hudCity');
        const hudSel = document.getElementById('hudSel');
        const hudHover = document.getElementById('hudHover');
        if (hudCity) hudCity.textContent = `City: ${currentCity || '-'}`;
        if (hudSel) hudSel.textContent = `Start: ${selectedNodes[0] || '-'}, End: ${selectedNodes[1] || '-'}`;
        if (hudHover) hudHover.textContent = `Hover: ${hoveredNode || '-'}`;
    }


    document.addEventListener('DOMContentLoaded', () => {
        canvas = document.querySelector('canvas');
        ctx = canvas.getContext('2d');
    // Prepare glow layers immediately
    buildGlowLayers();
    function resizeCanvas() {
            const topbar = document.querySelector('.topbar');
            const topbarHeight = topbar ? topbar.offsetHeight : 0;
            canvas.width = window.innerWidth;
            canvas.height = Math.max(300, window.innerHeight - topbarHeight - 56);
            if (graph) {
                precomputePositions();
                buildUniqueEdges();
                buildSpatialIndex();
                buildBaseLayer().then(() => { buildGlowLayers(); drawGraph(); });
            }
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        canvas.addEventListener('click', handleCanvasClick);
        canvas.addEventListener('mousemove', handleMouseMove);
        updateHUD();

        // Speed slider wiring
    const speedSlider = document.getElementById('speedSlider');
    const speedLabel = document.getElementById('speedLabel');
        if (speedSlider) {
            const updateSpeed = () => {
        const v = parseFloat(speedSlider.value || '1') || 1;
        // Map display value to internal multiplier: 1x => 0.1 (half of old 0.2x)
        anim.speedMultiplier = v * 0.1;
        if (speedLabel) speedLabel.textContent = `${v.toFixed(1)}x`;
            };
        // Initialize defaults: 1.0x
        try { speedSlider.value = '1'; } catch (_) {}
            speedSlider.addEventListener('input', updateSpeed);
            updateSpeed();
        }
    });
    </script>
</head>
<body>
        <!-- Minimalistic instructions modal -->
        <div id="instructions-modal" style="
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background: rgba(15,18,30,0.92); color: #fff; z-index: 9999;
            display: flex; align-items: center; justify-content: center; flex-direction: column;
            font-family: 'Segoe UI', Arial, sans-serif; font-size: 1.15rem; letter-spacing: 0.02em;">
            <div style="background: rgba(25,30,45,0.98); padding: 2.2em 2.5em; border-radius: 14px; box-shadow: 0 2px 24px #0007; text-align: center;">
                <h2 style="margin-bottom: 1em; font-size: 1.3em; font-weight: 500;">How to use</h2>
                <ul style="list-style: none; padding: 0; margin: 0 0 1.2em 0;">
                    <li>1. <b>Click a map button</b> to load a city.</li>
                    <li>2. <b>Click two points</b> on the map to select start and end.</li>
                    <li>3. <b>Click an algorithm</b> to visualize the pathfinding.</li>
                </ul>
                <button id="close-instructions" style="
                    background: #2a3b6e; color: #fff; border: none; border-radius: 6px;
                    padding: 0.6em 1.4em; font-size: 1em; cursor: pointer; box-shadow: 0 1px 6px #0003;">
                    Got it!
                </button>
            </div>
        </div>

    <div class="topbar">
        <div class="brand"><a href="{{ url_for('index') }}">MapFlow</a></div>
        <div class="controls">
            <div class="group">
                <span class="label">City:</span>
                <button class="CButton small" onclick="sendCity('Paris')">Paris</button>
                <button class="CButton small" onclick="sendCity('Rome')">Rome</button>
                <button class="CButton small" onclick="sendCity('Chicago')">Chicago</button>
                <button class="CButton small" onclick="sendCity('Berlin')">Berlin</button>
            </div>
            <div class="group">
                <span class="label">Algorithm:</span>
                <button class="CButton small" onclick="findPath('dijkstra')">Dijkstra</button>
                <button class="CButton small" onclick="findPath('a_star')">A*</button>
                <button class="CButton small" onclick="findPath('bfs')">BFS</button>
                <button class="CButton small" onclick="findPath('dfs')">DFS</button>
                <button class="CButton small" onclick="findPath('bi')">Bidirectional</button>
            </div>
            <div class="group">
                <span class="label">Speed:</span>
                <input id="speedSlider" type="range" min="0.1" max="3" step="0.1" value="1" />
                <span id="speedLabel" class="label">1.0x</span>
            </div>
            <div class="group">
                <button class="CButton small accent" onclick="resetSelection()">Reset</button>
            </div>
        </div>
    </div>
    <div class="hud">
        <span id="hudCity">City: -</span>
        <span id="hudSel">Start: -, End: -</span>
    </div>
    <!-- Loading overlay -->
    <div id="loadingOverlay" class="loading-overlay">
        <div class="spinner"></div>
        <div id="loadingText" class="loading-text">Loadingâ€¦</div>
    </div>
    <canvas></canvas>
        <script>
        document.addEventListener('DOMContentLoaded', function() {
            const modal = document.getElementById('instructions-modal');
            const closeBtn = document.getElementById('close-instructions');
            closeBtn.onclick = function() {
                modal.style.display = 'none';
            };
        });
        </script>
</body>
</html>